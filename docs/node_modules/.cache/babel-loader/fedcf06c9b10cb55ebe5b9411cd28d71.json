{"ast":null,"code":"/*\n * Copyright 2015, Yahoo Inc.\n * Copyrights licensed under the New BSD License.\n * See the accompanying LICENSE file for terms.\n */\nimport * as React from 'react';\nimport { Context } from './injectIntl';\nimport { invariantIntlContext } from '../utils'; // Since rollup cannot deal with namespace being a function,\n// this is to interop with TypeScript since `invariant`\n// does not export a default\n// https://github.com/rollup/rollup/issues/1267\n\nimport * as invariant_ from 'invariant';\nconst invariant = invariant_.default || invariant_;\nconst MINUTE = 60;\nconst HOUR = 60 * 60;\nconst DAY = 60 * 60 * 24;\n\nfunction selectUnit(seconds) {\n  const absValue = Math.abs(seconds);\n\n  if (absValue < MINUTE) {\n    return 'second';\n  }\n\n  if (absValue < HOUR) {\n    return 'minute';\n  }\n\n  if (absValue < DAY) {\n    return 'hour';\n  }\n\n  return 'day';\n}\n\nfunction getDurationInSeconds(unit) {\n  switch (unit) {\n    case 'second':\n      return 1;\n\n    case 'minute':\n      return MINUTE;\n\n    case 'hour':\n      return HOUR;\n\n    default:\n      return DAY;\n  }\n}\n\nfunction valueToSeconds(value, unit) {\n  if (!value) {\n    return 0;\n  }\n\n  switch (unit) {\n    case 'second':\n      return value;\n\n    case 'minute':\n      return value * MINUTE;\n\n    default:\n      return value * HOUR;\n  }\n}\n\nconst INCREMENTABLE_UNITS = ['second', 'minute', 'hour'];\n\nfunction canIncrement(unit = 'second') {\n  return INCREMENTABLE_UNITS.includes(unit);\n}\n\nfunction verifyProps(updateIntervalInSeconds, unit) {\n  invariant(!updateIntervalInSeconds || updateIntervalInSeconds && canIncrement(unit), 'Cannot schedule update with unit longer than hour');\n}\n\nexport class FormattedRelativeTime extends React.PureComponent {\n  constructor(props) {\n    super(props); // Public for testing\n\n    this._updateTimer = null;\n    this.state = {\n      prevUnit: this.props.unit,\n      prevValue: this.props.value,\n      currentValueInSeconds: canIncrement(this.props.unit) ? valueToSeconds(this.props.value, this.props.unit) : 0\n    };\n    verifyProps(props.updateIntervalInSeconds, props.unit);\n  }\n\n  scheduleNextUpdate({\n    updateIntervalInSeconds,\n    unit\n  }, {\n    currentValueInSeconds\n  }) {\n    clearTimeout(this._updateTimer);\n    this._updateTimer = null; // If there's no interval and we cannot increment this unit, do nothing\n\n    if (!updateIntervalInSeconds || !canIncrement(unit)) {\n      return;\n    } // Figure out the next interesting time\n\n\n    const nextValueInSeconds = currentValueInSeconds - updateIntervalInSeconds;\n    const nextUnit = selectUnit(nextValueInSeconds); // We've reached the max auto incrementable unit, don't schedule another update\n\n    if (nextUnit === 'day') {\n      return;\n    }\n\n    const unitDuration = getDurationInSeconds(nextUnit);\n    const remainder = nextValueInSeconds % unitDuration;\n    const prevInterestingValueInSeconds = nextValueInSeconds - remainder;\n    const nextInterestingValueInSeconds = prevInterestingValueInSeconds >= currentValueInSeconds ? prevInterestingValueInSeconds - unitDuration : prevInterestingValueInSeconds;\n    const delayInSeconds = Math.abs(nextInterestingValueInSeconds - currentValueInSeconds);\n    this._updateTimer = setTimeout(() => this.setState({\n      currentValueInSeconds: nextInterestingValueInSeconds\n    }), delayInSeconds * 1e3);\n  }\n\n  componentDidMount() {\n    this.scheduleNextUpdate(this.props, this.state);\n  }\n\n  componentDidUpdate() {\n    this.scheduleNextUpdate(this.props, this.state);\n  }\n\n  componentWillUnmount() {\n    clearTimeout(this._updateTimer);\n    this._updateTimer = null;\n  }\n\n  static getDerivedStateFromProps(props, state) {\n    if (props.unit !== state.prevUnit || props.value !== state.prevValue) {\n      return {\n        prevValue: props.value,\n        prevUnit: props.unit,\n        currentValueInSeconds: canIncrement(props.unit) ? valueToSeconds(props.value, props.unit) : 0\n      };\n    }\n\n    return null;\n  }\n\n  render() {\n    return React.createElement(Context.Consumer, null, intl => {\n      invariantIntlContext(intl);\n      const formatRelativeTime = intl.formatRelativeTime,\n            Text = intl.textComponent;\n      const _this$props = this.props,\n            children = _this$props.children,\n            value = _this$props.value,\n            unit = _this$props.unit,\n            updateIntervalInSeconds = _this$props.updateIntervalInSeconds;\n      const currentValueInSeconds = this.state.currentValueInSeconds;\n      let currentValue = value || 0;\n      let currentUnit = unit;\n\n      if (canIncrement(unit) && currentValueInSeconds != null && updateIntervalInSeconds) {\n        currentUnit = selectUnit(currentValueInSeconds);\n        const unitDuration = getDurationInSeconds(currentUnit);\n        currentValue = Math.round(currentValueInSeconds / unitDuration);\n      }\n\n      const formattedRelativeTime = formatRelativeTime(currentValue, currentUnit, Object.assign({}, this.props));\n\n      if (typeof children === 'function') {\n        return children(formattedRelativeTime);\n      }\n\n      if (Text) {\n        return React.createElement(Text, null, formattedRelativeTime);\n      }\n\n      return formattedRelativeTime;\n    });\n  }\n\n}\nFormattedRelativeTime.displayName = 'FormattedRelativeTime';\nFormattedRelativeTime.defaultProps = {\n  value: 0,\n  unit: 'second'\n};\nexport default FormattedRelativeTime;","map":null,"metadata":{},"sourceType":"module"}